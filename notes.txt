git add -A 
git commit -m 
git status 
git push origin master

notes:
Idea: e-marketplace where u can view goods or services 


model: user - product - categorie - (product-categorie )->joint-table

user: username email password
product: Name - description - image - price 
categorie: name 
product-categorie: product_id categorie_id user_it (like or favorite attribute)

future: comments-also can be an attr in p-c <--- 
future: add location attribute on product using iframe 

note->the user_id in product categorie is to count the likes or favorites
relationships:
user has many_products 
product belongs to user 
product has many categories through p-c 
categorie has many product through p-c 

this is new to me i looked up how to upload images to the application found out that we have to install something called active storage and migrate it in the database

  rails active_storage:install
The dependency tzinfo-data (>= 0) will be unused by any of the platforms Bundler is installing for. Bundler is installing for ruby but the dependency is only for x86-mingw32, x86-mswin32, x64-mingw32, java. To add those platforms to the bundle, run `bundle lock --add-platform x86-mingw32 x86-mswin32 x64-mingw32 java`.
Copied migration 20200707044643_create_active_storage_tables.active_storage.rb from active_storage
[21:46:43]  e-haggle (master)
// â™¥  rails db:migrate
The dependency tzinfo-data (>= 0) will be unused by any of the platforms Bundler is installing for. Bundler is installing for ruby but the dependency is only for x86-mingw32, x86-mswin32, x64-mingw32, java. To add those platforms to the bundle, run `bundle lock --add-platform x86-mingw32 x86-mswin32 x64-mingw32 java`.
== 20200707044643 CreateActiveStorageTables: migrating ========================
-- create_table(:active_storage_blobs, {})
   -> 0.0035s
-- create_table(:active_storage_attachments, {})
   -> 0.0035s
== 20200707044643 CreateActiveStorageTables: migrated (0.0109s) ===============
-->>>>>>the console rendered the above

question:
----->if the blob saves in the database as binary data or another way versus saving the actual url on a server and call it back in an url tag<<-----



after around 8 or 9 hours of trying to figure out how to import jquery for the materialize gem correctly i finally figured it out 
https://medium.com/@guilhermepejon/how-to-install-materialize-css-in-rails-6-0-0-beta2-using-webpack-347c03b7104e
https://www.botreetechnologies.com/blog/introducing-jquery-in-rails-6-using-webpacker 
following these 2 guids it worked with some slight changes that i have notated above the files also make sure to create a stylesheet folder inside of the javascript file in the asset pipeline and import the materialize there using this code @import url(materialize-css/dist/css/materialize);

moving on working on the user model I saw some stuff about validating the user email in a certain hashing method 
and i also found a good resource like a website to check the format for email 
https://rubular.com/ this website here will check for the expression if it is valid or not
i might attach a picture if anyone is confused but basically just follow the format and u have to escape the / and put an i at the end 
if u do it incorrectly the website will correct you. i found it to be very helpful

working on testing if we run command rails test it should let us know if we have tests or not i put some basic tests for 
categories in the model test folder also turns out we can generate a test scaffold by using the following command
rails generate test_unit:scaffold category but instead i just generated it automatically with the controller 
went ahead and wrote the scaffold tests but those usually get auto generated with the scaffold unit test generator and  now im going to try and work on the controller test integration, i might alter them a bit depending on my project

going to try and add admin functionality to users model
here im going to add an extra column admin and set it base value to false 
so the table will look something like this 

id|username|email|password|admin
---------------------------------
1 |  user1 |     | pass   |false
---------------------------------
2 |        | ema |        |false
---------------------------------
3 |        |     |        |false
where no one starts as an admin to begin with
after creating and migrating the admin to users table we can go check in the console 
do Users.all we should have an additional attribute admin: false that is always false
2.6.1 :001 > User.all
   (0.6ms)  SELECT sqlite_version(*)
  User Load (0.3ms)  SELECT "users".* FROM "users" LIMIT ?  [["LIMIT", 11]]
 => #<ActiveRecord::Relation [#<User id: 2, username: "updating from user1", email: "aniss@gmail.com", password_digest: [FILTERED], created_at: "2020-07-09 22:31:34", updated_at: "2020-07-09 22:37:00", admin: false>, #<User id: 
3, username: "i will delete", email: "iwilldelete@mail.com", password_digest: [FILTERED], created_at: "2020-07-09 
22:45:20", updated_at: "2020-07-09 22:45:20", admin: false>]>
2.6.1 :002 > user = User.first
  User Load (0.3ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT ?  [["LIMIT", 1]]
 => #<User id: 2, username: "updating from user1", email: "aniss@gmail.com", password_digest: [FILTERED], created_at: "2020-07-09 22:31:34", updated_at: "2020-07-09 22:37:00", admin: false>
2.6.1 :003 > user.admin?
 => false 
in the console we can do user.toggle!(:admin) so that the local variable we have defined will toggle the admin value on 
so that user now is an admin
this will look as follows


2.6.1 :001 > user = User.find(4)
   (0.6ms)  SELECT sqlite_version(*)
  User Load (0.3ms)  SELECT "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 4], ["LIMIT", 1]]
 => #<User id: 4, username: "ADMIN", email: "admin@mail.com", password_digest: [FILTERED], created_at: "2020-07-09 23:52:09", updated_at: "2020-07-09 23:52:09", admin: false>
2.6.1 :002 > user.toggle!(:admin)
   (0.1ms)  begin transaction
  User Update (5.8ms)  UPDATE "users" SET "updated_at" = ?, "admin" = ? WHERE "users"."id" = ?  [["updated_at", "2020-07-09 23:52:47.280914"], ["admin", 1], ["id", 4]]
   (9.4ms)  commit transaction
 => true
so now we can use this feature and add special previlages for admins using views and controllers